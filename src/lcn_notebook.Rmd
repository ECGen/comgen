---
title: "LCN: Lichen interaction network study"
author: MK Lau
---

<!-- 
rmarkdown::render("lcn_notebook.Rmd", 
	output_format = "pdf_document", 
	output_dir = "../results") 

rmarkdown::render("lcn_notebook.Rmd", 
	output_format = "md_document", 
	output_dir = "../results") 
-->

```{r load-data, echo = FALSE, results = "hide", warnings = FALSE, message = FALSE}

## Check for supporting packages
pkg.list <- c("MuMIn", "lme4", "RLRsim", "vegan", "ecodist", 
              "bipartite", "RColorBrewer", "enaR", "devtools", 
              "xtable", "reshape")
       ## install packages that are not installed
if (any(!(pkg.list %in% installed.packages()[, 1]))){
    sapply(pkg.list[which(!(pkg.list %in% installed.packages()[, 1]))], 
           install.packages, dependencies = TRUE, 
           repos = 'http://cran.us.r-project.org')
}
       ## Check non-CRAN packages
if (!("ComGenR" %in% installed.packages()[, 1])){
    devtools::install_github("ECGen/ComGenR")
}
if (!("conetto" %in% installed.packages()[, 1])){
    devtools::install_github("ECGen/conetto")
}
       ## Load libraries
sapply(c(pkg.list, "ComGenR", "conetto"), library, 
       quietly = TRUE, character.only = TRUE)

### Loading data objects
## onc.com = "community" occurrences summed across all cells for each tree
## onc.q = occurrence matrices separated out for each tree
## onc.geno = genotypes
## prb.onc = percent rough bark (averaged between the upper and lower)

### Data notes:
## Trees were removed from the analysis genotype RL6 and N1.31
## No physciods
## Lecanoras merged
                                        # Loading data
xgal.size <- read.csv("../data/lcn/ONC_Xgal_SizeData_May2011.csv")
garden.data <- read.csv("../data/lcn/LCO_data_ONC_PIT.csv")
                                        # remove genotype RL6 and N1.31
garden.data <- garden.data[garden.data$Geno!='RL6',]
garden.data <- garden.data[garden.data$Tree!='N1.31',]
                                        #separate onc
garden.data[,1] <- as.character(garden.data[,1])
g1 <- substr(garden.data[,1],2,2)
g1[g1!='P'] <- 'onc'
onc <- garden.data[g1 == 'onc',]
colnames(onc)[which(colnames(onc) == "Ls")] <- "Lh"
pit <- garden.data[g1 == 'P',]
					#tree overlap between years
unique(onc$Tree[onc$Year == '2010']) %in% unique(onc$Tree[onc$Year == '2011'])
unique(onc$Tree[onc$Year == '2011']) %in% unique(onc$Tree[onc$Year == '2010'])
                                        # Checking the data
if (!(all(table(onc[,1]) == 100))){for (i in 1:1000){
                                     print('Warning: check input data!!!')}}
                                        # Separate trees
                                        # onc
colnames(onc)[7:ncol(onc)] <- substr(colnames(onc)[7:ncol(onc)],1,2)
onc.q <- split(onc,paste(onc[,1],onc[,2]))
onc.q <- lapply(onc.q,function(x) x[,7:ncol(x)])
                                        # pit
colnames(pit)[7:ncol(pit)] <- substr(colnames(pit)[7:ncol(pit)],1,2)
pit.q <- split(pit,paste(pit[,1],pit[,2]))
pit.q <- lapply(pit.q,function(x) x[,7:ncol(x)])
                                        # Get genotype
onc.geno <- unlist(sapply(names(onc.q),
                          function(x) strsplit(x,split=' ')[[1]][2]))
pit.geno <- unlist(sapply(names(pit.q),
                          function(x) strsplit(x,split=' ')[[1]][2]))
                                        # Xgal size data
xgs <- xgal.size[-1:-7, -(ncol(xgal.size) - 1):-ncol(xgal.size)]
xgs.cols <- xgal.size[7, -(ncol(xgal.size) - 1):-ncol(xgal.size)]
colnames(xgs) <- gsub("\\#", "", as.character(unlist(xgs.cols)))
xgs <- xgs[, 1:13]
xgs <- apply(xgs, 2, gsub, pattern = "\\,", replacement = "") 
xgs.dim <- xgs[, "Measurement"]
xgs.geno <- xgs[, "Genotype"]
xgs.tree <- xgs[, "Tree"]
xgs <- xgs[, grep("Thallus", colnames(xgs))] 
                                        # fix genotypes
                                        # t6
xgs.geno[grep("T6", xgs.geno)] <- "T6"
xgs.geno[grep("H10", xgs.geno)] <- "H-10"
                                        # Coercing to numeric
xgs <- apply(xgs, 2, as.numeric) 
                                        # Dealing with NA values
xgs.geno <- xgs.geno[grep("Dimension", xgs.dim)]
xgs.tree <- xgs.tree[grep("Dimension", xgs.dim)]
xgs <- xgs[grep("Dimension", xgs.dim), ]
xgs.dim <- xgs.dim[grep("Dimension", xgs.dim)]
                                        # Convert to cm
xgs <- xgs * 0.1
xgs.ellipse <- pi * xgs[xgs.dim == "Dimension 1", ] * 
  xgs[xgs.dim == "Dimension 2", ]
xgs.geno <- xgs.geno[xgs.dim == "Dimension 1"]
xgs.tree <- xgs.tree[xgs.dim == "Dimension 1"]
                                        # package all xgs related data
xgs.data <- data.frame(tree = xgs.tree, geno = xgs.geno, 
                       mean.thallus = apply(xgs.ellipse, 1, 
                                            mean, 
                                            na.rm = TRUE),
                       median.thallus = apply(xgs.ellipse, 1, 
                                              median, 
                                              na.rm = TRUE),
                       xgs.ellipse)
                                        # remove trees not done (i.e. all NA)
xgs.data <- xgs.data[apply(xgs.data[, grep("Thallus", 
                                           colnames(xgs.data))], 1, 
                           function(x) !(all(is.na(x)))),]
                                        # Roughness in the Garden
rough <- read.csv("../data/lcn/ONC_raw_roughness.csv")
                                        # Isolate roughness
rough <- rough[, 1:5]
                                        # Isolate north quadrats
rough <- rough[grepl("North", rough[,3]), ]
                                        # Average roughness
avg.rough <- tapply(rough[,5], rough[,1], mean)
r.tree <- names(avg.rough)
r.tree <- sub('-', '\\.', r.tree)
r.tree <- sub('\\.0', '\\.', r.tree)
names(avg.rough) <- r.tree
                                        # match roughness to to ses values
load("../data/lcn/lcn_onc_ses.rda")
onc.ses <- unlist(os[,1])
onc.ses[is.na(onc.ses)] <- 0
names(onc.ses) <- rownames(os)
if (!(all(names(onc.ses) == names(onc.q)))){print('Holy crap!')}
ses.tree <- as.character(sapply(names(onc.ses),
                                function(x) unlist(strsplit(x,split=' '))[1]))
onc.rough <- avg.rough[match(ses.tree, r.tree)]
if (!(all(ses.tree == names(onc.rough)))){print('Holy Crap!')}
       ## RFLP distance values from Zink from Martinsen
rflp.d <- readLines("../data/lcn/rflp_queller_goodnight.txt")
rflp.d <- lapply(rflp.d, strsplit,split='\t')
rflp.d <- lapply(rflp.d, function(x) x[[1]])
rflp.d[[61]] <- c(rflp.d[[61]], "")
rflp.d <- do.call(rbind, rflp.d)
rflp.n <- rflp.d[1, -1]
rflp.d <- rflp.d[-1, -1]
diag(rflp.d) <- 1
rflp.d <- matrix(as.numeric(rflp.d),nrow=nrow(rflp.d))
rownames(rflp.d) <- colnames(rflp.d) <- rflp.n
rflp.d <- rflp.d[rownames(rflp.d) %in% unique(onc.geno), 
                 colnames(rflp.d) %in% unique(onc.geno)]
rflp.d <- rflp.d[match(unique(onc.geno), rownames(rflp.d)), 
                 match(unique(onc.geno),rownames(rflp.d))]
if (!(all(rownames(rflp.d) == unique(onc.geno)))){
    print("Holy crap, rflp.d names match error")
}

## Duplicate by genotype? Would this work to make the RFLPs values replicated?
                                        # Coerce to distance matrices
rflp.d <- as.dist(rflp.d)
                                        # Lichen Network Models
                                        # onc
cn.onc <- lapply(split(onc[, -1:-6], onc[, "Tree"]), coNet, 
                 ci.p = 95)
cn.sign.onc <- lapply(split(onc[, -1:-6], onc[, "Tree"]), coNet, 
                      ci.p = 95)
cn.d.onc <- distNet(cn.onc, method = "euclidean")
cn.d.onc.na <- distNet(cn.onc[names(cn.onc) %in% na.omit(onc.dat)$tree.id], 
                       method = "euclidean")
                                        # pit
cn.pit <- lapply(split(pit[, -1:-6], pit[, "Tree"]), coNet, ci.p = 95)
cn.sign.pit <- lapply(split(pit[, -1:-6], pit[, "Tree"]), coNet, ci.p = 95)
cn.d.pit <- distNet(cn.pit, method = "bc")
                                        # genotype means and mean distances
onc.tree <- do.call(rbind, strsplit(names(onc.geno), " "))[, 1]
cn.mu.onc <- list()
for (i in 1:length(unique(onc.geno))){
    cn.mu.onc[[i]] <- meanNet(cn.onc[onc.geno == unique(onc.geno)[i]])
}
names(cn.mu.onc) <- unique(onc.geno)
cn.mu.d.onc <- distNet(cn.mu.onc, method = "bc")
                                        # mean bark roughness calculations
prb.mu.onc <- tapply(onc.rough, onc.geno, mean)
prb.mu.d.onc <- dist(prb.mu.onc)
                                        # network statistics
ns.onc <- lapply(lapply(cn.onc, function(x) 
    abs(sign(x))), enaR:::structure.statistics)
ns.onc <- do.call(rbind, ns.onc)
                                        # Ratio P / N
ns.rpn <- unlist(lapply(cn.onc, function(x)
    mean(x[x > 0]) / mean(x[x < 0])))

                                        # modularity
cn.mod.onc <- matrix(nrow = length(cn.onc), ncol = 2)
for (i in 1:length(cn.onc)){
    if (sum(sign(cn.onc[[i]])) >= 3){
        ## Networks with modules = 2  9 14 19 20 25 27 28 30 31 42 44 54 57
        mod.tmp <- computeModules(cn.onc[[i]])
        cn.mod.onc[i, 1] <- slot(mod.tmp, "likelihood") 
        cn.mod.onc[i, 2] <- nrow(slot(mod.tmp, "modules")) - 1 
    }else{cn.mod.onc[i] <- NA}
}
cn.mod.onc[is.na(cn.mod.onc)] <- 0
names(cn.mod.onc) <- c("mod.lik", "mod.n")
                                        # graph level centralization 
dcen.onc <- unlist(lapply(cn.onc, function(x) 
    sna::centralization(x, FUN = sna::degree, normalize = FALSE)))
onc.ns <- cbind(ns.onc, Cen = dcen.onc, 
                mod.lik = cn.mod.onc[, 1], mod.n = cn.mod.onc[, 2])
if (!(all(onc.tree == names(cn.onc)))){print("Danger Will Robinson!")}
                                        # species centralities
cen.spp <- lapply(cn.onc[names(cn.onc) %in% na.omit(onc.dat)$tree.id], 
                  sna::degree, rescale = FALSE)
cen.spp <- do.call(rbind, cen.spp)
colnames(cen.spp) <- colnames(cn.onc[[1]])
summary(aov(value ~ X2, data = melt(cen.spp)))
TukeyHSD(aov(value ~ X2, data = melt(cen.spp)))
apply(cen.spp, 2, sd) / sqrt(nrow(cen.spp))

                                        # Community data
onc.com <- do.call(rbind,lapply(onc.q,function(x) apply(x,2,sum)))
onc.R <- apply(sign(onc.com),1,sum)
onc.H <- vegan::diversity(onc.com)
onc.com.gm <- apply(onc.com, 2, 
                    function(x, g) tapply(x, g, mean), g = onc.geno)
onc.com.gm.rel <- apply(onc.com.gm, 2, function(x) x/max(x))
onc.com.rel <- apply(onc.com, 2, function(x) x/max(x))
onc.com.rel <- cbind(onc.com.rel, 
                     ds = rep(min(onc.com.rel[onc.com.rel != 0]) / 1000, 
                              nrow(onc.com.rel)))
onc.com <- cbind(onc.com, 
                 ds = rep(min(onc.com[onc.com != 0]) / 1000, 
                          nrow(onc.com)))
                                        # pit genotype mean community
pit.com <- do.call(rbind,lapply(pit.q,function(x) apply(x,2,sum)))
pit.com.gm <- apply(pit.com, 2, 
                    function(x, g) tapply(x, g, mean), g = pit.geno)
pit.com.gm.rel <- apply(pit.com.gm, 2, function(x) x/max(x))
pit.com.gm.rel[is.na(pit.com.gm.rel)] <- 0
                                        # Lichen community metrics
                                        # Percent Total Cover
ptc.onc <- unlist(lapply(onc.q, 
                         function(x) sum(apply(x, 1, 
                                               function(x) sign(sum(x))))))
                                        # Species richness
spr.onc <- apply(onc.com[, colnames(onc.com) != "ds"], 1, 
                 function(x) sum(sign(x)))
                                        # Diversity
spd.onc <- diversity(onc.com[, colnames(onc.com) != "ds"])
                                        # Evenness
spe.onc <- spd.onc / log(specnumber(onc.com[, colnames(onc.com) != "ds"]))
spe.onc[is.na(spe.onc)] <- 0
                                        # Vectors for network similarity
## ns.vec.onc <- envfit(ord, 
##        data.frame(onc.ns[, c("L", "Cen")], 
##                   R = onc.rough, Cov = ptc.onc))
## Creating distance matrices that match rflp
## this is for the "mean" distance matrices
cn.mu.d <- as.matrix(cn.mu.d.onc)
prb.mu.d <- as.matrix(prb.mu.d.onc)
prb.mu.d <- prb.mu.d[match(rownames(cn.mu.d), rownames(prb.mu.d)), 
                     match(rownames(cn.mu.d), rownames(prb.mu.d))]
prb.mu.d <- as.dist(prb.mu.d)
onc.com.mu <- apply(onc.com[, -ncol(onc.com)], 2, 
                    function(x, g) tapply(x, g, mean), g = onc.geno)
onc.com.mu <- onc.com.mu[match(rownames(cn.mu.d), rownames(onc.com.mu)), ]
onc.com.mu.d <- vegdist(onc.com.mu)
if (!(all(c(all(rownames(as.matrix(rflp.d)) == 
                rownames(as.matrix(cn.mu.d.onc))),
            all(rownames(as.matrix(rflp.d)) == 
                rownames(as.matrix(prb.mu.d))),
            all(rownames(as.matrix(rflp.d)) == 
                rownames(as.matrix(onc.com.mu.d))))))){
    warning("Warning: distance matrices are not aligned.")
}else{
    print("Distance matrices good to go!")
}

                                        # Bipartite analysis
nperm <- 20
if (!(file.exists("../data/lcn/nest_rel_onc.rda"))){
    nest.onc <- nestedness(onc.com.rel[, colnames(onc.com.rel) != "ds"], 
                           n.nulls = 999)
    dput(nest.onc, "../data/lcn/nest_rel_onc.rda")
}else{
  nest.onc <- dget("../data/lcn/nest_rel_onc.rda")
}
if (!(file.exists("../data/lcn/null_mod_onc.csv"))){
    obs.mod.onc <- bipartite::computeModules(
                                onc.com.rel[, colnames(onc.com.rel) != "ds"])
    mods.onc <- tail(apply(slot(obs.mod.onc, "modules"), 2, 
                           function(x) sum(sign(x[2:length(x)]) *
                                               (1:(length(x) - 1)))),
                     sum(dim(onc.com[, colnames(onc.com) != "ds"])))
    mods.onc <- list(sp = tail(mods.onc, 
                               ncol(onc.com[, colnames(onc.com) != "ds"])), 
                     tree = head(mods.onc, nrow(onc.com)))
    sim.onc <- lapply(1:nperm, sim.com, x = onc.q)
    sim.onc <- lapply(sim.onc, function(x) x / max(x))
    nul.mod.onc <- lapply(sim.onc, function(x) bipartite::computeModules(x))
    nul.mod.onc <- unlist(lapply(nul.mod.onc, slot, "likelihood"))
    dput(mods.onc, "../data/lcn/mod_list_onc.rda")
    write.csv(slot(obs.mod.onc, "likelihood"), 
              "../data/lcn/obs_mod_onc.csv", 
              row.names = FALSE)
    write.csv(nul.mod.onc, 
              "../data/lcn/null_mod_onc.csv", 
              row.names = FALSE)
}else{
    obs.mod.onc <- read.csv("../data/lcn/obs_mod_onc.csv")[1]
    nul.mod.onc <- read.csv("../data/lcn/null_mod_onc.csv")[,1]
    z.mod.onc <- (obs.mod.onc - mean(nul.mod.onc)) / sd(nul.mod.onc)
    mods.onc <- dget("../data/lcn/mod_list_onc.rda")
}
pval.mod.onc <- length(nul.mod.onc[nul.mod.onc >= obs.mod.onc]) / 
  length(nul.mod.onc)
if (pval.mod.onc == 0){pval.mod.onc <- 1/nperm}
z.mod.onc <- (obs.mod.onc - mean(nul.mod.onc)) / sd(nul.mod.onc)
bp.mod.onc <- round(unlist(c(nperm = nperm, obs = obs.mod.onc, 
                mu.sim = mean(nul.mod.onc), sd.sim = sd(nul.mod.onc), 
                z = z.mod.onc, p.value = pval.mod.onc)), 5)

## NMDS ordinations
                                        # community ordination
if (!file.exists("../data/lcn/onc_nmds.csv")){
    nms.info.onc <- capture.output(nms.onc <- nmds.min(nmds(
        vegdist(onc.com.rel), 2, 2)))
    write.csv(nms.onc, "../data/lcn/onc_nmds.csv", 
              row.names = FALSE)
    write.table(nms.info.onc, 
                "../data/lcn/onc_nmds_info.txt", 
                col.names = FALSE, row.names = FALSE)
}else{nms.onc <- read.csv("../data/lcn/onc_nmds.csv")}
                                        # Network ordination
if (!(file.exists("../data/lcn/conet_nmds.csv"))){
    cn.nmds.stats.onc <- capture.output(
      cn.nms.onc <- nmds.min(nmds(cn.d.onc, 2, 2)))
    write.csv(cn.nms.onc, "../data/lcn/conet_nmds.csv", 
              row.names = FALSE)
    write.table(cn.nmds.stats.onc, 
                "../data/lcn/conet_nmds_info.txt", 
                col.names = FALSE, row.names = FALSE)
}else{cn.nms.onc <- read.csv("../data/lcn/conet_nmds.csv")}
                                        # Vector fitting
nv.onc <- envfit(cn.nms.onc, data.frame(onc.com[, colnames(onc.com) != 'ds'], 
                                        R = onc.rough, 
                                        C = onc.ns[, c("C")], 
                                        A = ptc.onc))
cv.onc <- envfit(nms.onc, data.frame(onc.com[, colnames(onc.com) != 'ds'], 
                                        R = onc.rough, 
                                        C = onc.ns[, c("C")], 
                                     A = ptc.onc))
                                        #genotype means
omu <- apply(onc.com[,colnames(onc.com) != 'ds'], 2, 
             function(x,g) tapply(x,g,mean),g=onc.geno)
oms <- tapply(onc.ses, onc.geno, mean)
oms.d <- dist(oms[match(rownames(as.matrix(rflp.d)),names(oms))])
                                        #bark roughness means
oprbmu <- tapply(onc.rough,onc.geno,mean)
oprbmu <- oprbmu[match(rownames(as.matrix(rflp.d)),names(oprbmu))]
                                        #get araujo coordinates
coord <- read.csv("../data/lcn/lcn_coord_onc.csv")
rownames(coord) <- coord[,1]
coord <- coord[,-1]
                                        # packing into a dataframe
tree <- onc.geno
for (i in 1:length(unique(onc.geno))){
    tree[onc.geno == unique(onc.geno)[i]] <- 
      1:length(tree[onc.geno == unique(onc.geno)[i]])
}
tree <- factor(tree)
tree.id <- do.call(rbind, strsplit(names(ptc.onc), split = " "))[, 1]
                                        # add chemistry data
onc.nc <- read.csv("../data/lcn/ONC_phytochem_NC.csv")
onc.tan <- read.csv("../data/lcn/ONC_phytochem_tannin.csv")
onc.nc[, 1] <- as.character(paste0("N", gsub("-", "\\.", onc.nc[, 1])))
onc.tan[, 1] <- as.character(paste0("N", gsub("-", "\\.", onc.tan[, 1])))
                                        # rename headers
                                        # mass is in mg
colnames(onc.nc)[1:4] <- c("tree.id", "sample.mass", "N", "C")
colnames(onc.tan)[1] <- "tree.id"
colnames(onc.tan)[grep("X.CT", colnames(onc.tan))] <- "CT"
                                        # add C:N ratio
onc.nc$rCN <- onc.nc$N / onc.nc$C
                                        # pH data
onc.ph <- read.csv("../data/lcn/ONC_Bark_lichen_pH_data.csv")
onc.ph[, "tree.id"] <- gsub("-", ".", onc.ph[, "tree.id"])
onc.ph[, "tree.id"] <- gsub("\\.0", "\\.", onc.ph[, "tree.id"])
                                        # N7.16 is possibly N7.10
onc.ph[onc.ph[, "tree.id"] == "N7.16", "tree.id"] <- "N7.10"
                                        # updated pH from Lamit 
onc.ph[!is.na(onc.ph[, "pH2"]), "pH"] <- 
  apply(onc.ph[!is.na(onc.ph[, "pH2"]), c("pH","pH2")], 1, mean)
                                        # collect into a single df
onc.dat <- data.frame(tree.id, PC = ptc.onc, SR = spr.onc, 
                      SD = spd.onc, SE = spe.onc,
                      geno = factor(onc.geno), tree = tree, 
                      BR = onc.rough, onc.ns[, c("L", "Cen")])
                                        # Get to match onc.dat
onc.ph <- onc.ph[onc.ph[, "tree.id"] %in% onc.dat[, "tree.id"], ]
onc.ph <- onc.ph[match(onc.dat[, "tree.id"], onc.ph[, "tree.id"]), ]
                                        # append chemistry to onc.dat
onc.dat <- data.frame(onc.dat, 
                      C = onc.nc[match(onc.dat[, "tree.id"], 
                          onc.nc[, "tree.id"]), "C"],
                      N = onc.nc[match(onc.dat[, "tree.id"], 
                          onc.nc[, "tree.id"]), "N"],
                      CN = onc.nc[match(onc.dat[, "tree.id"], 
                          onc.nc[, "tree.id"]), "rCN"], 
                      CT = onc.tan[match(onc.dat[, "tree.id"], 
                          onc.tan[, "tree.id"]), "CT"], 
                      pH = onc.ph[, "pH"])
                                        # Plot calculations
pw.onc <- onc.com.rel[, colnames(onc.com.rel) != "ds"]
pw.onc <- pw.onc[order(apply(pw.onc, 1, sum), decreasing = TRUE), 
                 order(apply(pw.onc, 2, sum), decreasing = TRUE)]
rownames(pw.onc) <- onc.geno
col.pal <- RColorBrewer::brewer.pal((max(unlist(mods.onc))), "Paired")
                                        # Figure ordinations
                                        # Communities
if (file.exists("../data/lcn/nms_com_onc.rda")){
    nms.com <- dget(file = "../data/lcn/nms_com_onc.rda")    
}else{
    set.seed(12345)
    nms.com <- nmds(vegdist(onc.com.rel), 2, 3)
    dput(nms.com, file = "../data/lcn/nms_com_onc.rda")
}
                                        # Networks
if (file.exists("../data/lcn/nms_cn_onc.rda")){
    nms.cn <- dget(file = "../data/lcn/nms_cn_onc.rda")    
}else{
    set.seed(12345)
    nms.cn <- nmds(cn.d.onc, 1, 2)
    dput(nms.cn, file = "../data/lcn/nms_cn_onc.rda")
}
ord.com <- nmds.min(nms.com, 3)
ord.cn <- nmds.min(nms.cn, 2)
                                        # Vectors for plotting
                                        # Composition
vec.env <- onc.dat[, c("BR", "SR", "Cen")]
vec.com <- envfit(ord.com, env = vec.env, perm = 10000, 
                  choices = c(1,2))
                                        # Network similarity
vec.cn <- envfit(ord.cn, env = vec.env, perm = 10000, 
                  choices = c(1,2))
                                        # onc
if (!("mod_obsval_onc.csv" %in% dir("../data/lcn"))){
  mod.onc <- slot(bipartite::computeModules(rel(onc.com[, -ncol(onc.com)]), 
                                                  deep = FALSE), 
                         "likelihood")
  write.csv(mod.onc, file = "../data/lcn/mod_obsval_onc.csv", row.names = FALSE)
}else{
  mod.onc <- read.csv(file = "../data/lcn/mod_obsval_onc.csv")[, 1]
}
if (!("mod_simvals_onc.csv" %in% dir("../data/lcn"))){
        onc.sweb <- simulate(vegan::nullmodel(onc.com[, -ncol(onc.com)], 
                                              method = "swsh_samp_c"), 99)
        for (i in 1:dim(onc.sweb)[3]){onc.sweb[,, i] <- rel(onc.sweb[,, i])}
        onc.smod <- apply(onc.sweb, 3, bipartite::computeModules)
        mods.onc.sweb <- unlist(lapply(onc.smod, slot, name = "likelihood"))
        write.csv(mods.onc.sweb, 
                  file = "../data/lcn/mod_simvals_onc.csv", 
                  row.names = FALSE)
# nest.onc <- bipartite::nestedness(onc.com.rel)
}else{
    mods.onc.sweb <- read.csv(
      file = "../data/lcn/mod_simvals_onc.csv")[, 1]
}

                                        # pit
if (!("mod_obsval_pit.csv" %in% dir("../data/lcn"))){
        mod.pit <- slot(bipartite::computeModules(rel(pit.com), deep = FALSE), 
                         "likelihood")
        write.csv(mod.pit, 
                  file = "../data/lcn/mod_obsval_pit.csv", 
                  row.names = FALSE)
}else{
    mod.pit <- read.csv(
      file = "../data/lcn/mod_obsval_pit.csv")[, 1]
}
if (!("mod_simvals_pit.csv" %in% dir("../data/lcn"))){
  pit.sweb <- simulate(vegan::nullmodel(pit.com, method = "swsh_samp_c"), 99)
for (i in 1:dim(pit.sweb)[3]){pit.sweb[,, i] <- rel(pit.sweb[,, i])}
  pit.smod <- apply(pit.sweb, 3, bipartite::computeModules)
  mods.pit.sweb <- unlist(lapply(pit.smod, slot, name = "likelihood"))
  write.csv(mods.pit.sweb, 
            file = "../data/lcn/mod_simvals_pit.csv", 
            row.names = FALSE)
# nest.pit <- bipartite::nestedness(pit.com.rel)
}else{
  mods.pit.sweb <- read.csv(
    file = "../data/lcn/mod_simvals_pit.csv")[, 1]
}

### Wild data
###
###
x <- read.csv("../data/lcn/lco_Apr2012.csv")
                                        #remove notes
x <- x[,colnames(x)!='NOTES.']
x <- x[,colnames(x)!='dead']
                                        #
x <- na.omit(x)
                                        # remove gnu.44 = FREMONT
x <- x[x$tree != 'gnu.44',]
                                        # rm ll.6, tree with super smooth bark
x <- x[x$tree != 'll.6',]
x$tree <- factor(as.character(x$tree))
                                        #condense species
                                        #lecanora, there can be only one!
lec.sp <- apply(x[,c(6,8,10,18)], 1, function(x) sign(any(x!=0)))
                                        # no physcioids!
                                        # phy.spp <- apply(x[,c(13,14,15,16)], 
                                        # 1,function(x) sign(any(x!=0)))
x <- cbind(x, lec = lec.sp)
x <- x[, -c(6,8,10,18)]
x <- x[, colnames(x) != 'physcioid']
                                        #break into quadrat list (x.q)
quads <- paste(x$tree, x$quadrat)
colnames(x)[5:ncol(x)] <- c('Xg','Cs', 'Xm', 'fgb', 'Rs', 
                            'Pm' ,'Pa', 'Pu','Ch','Ls')
x <- x[colnames(x) != 'fgb']
x.q <- split(x,quads)
wild.com <- split(x,x$tree)
wild.com <- do.call(rbind,lapply(wild.com,function(x) apply(x[,-1:-4],2,sum)))
wild.com.rel <- apply(wild.com, 2, function(x) x/max(x))
wild.com.rel[is.na(wild.com.rel)] <- 0
wild.q <- lapply(split(x,x$tree),function(x) x[,-1:-4])
                                        #data from lamit
env <- read.csv("../data/lcn/Uinta2012_all_data_from_Lamit.csv")
env <- env[is.na(env$Pct.Roughness) == FALSE,]
env[,1] <- sub('\\?','',
               sub('\\.0','\\.', 
                   sub('\\_','\\.', 
                       sub('\\-','\\.',tolower(as.character(env[,1]))))))
env[env[,1] == 'll.6_(znu.29)',1] <- 'll.6'
env[env[,1] == 'gnu.85.1ftaway',1] <- 'gnu.85'
env$Quad.Loc <- as.character(sapply(as.character(env$Quad.Loc),
                                    function(x) 
                                      unlist(strsplit(x,split='_'))[2]))
env$Quad.Loc <- sub('\\-','\\.',env$Quad.Loc)
env$Quad.Loc <- paste('n',env$Quad.Loc,sep='')
                                        #remove southern aspect
env <- env[env$Aspect!='South',]
env.tid <- paste(env$Tree.ID,env$Quad.Loc)
                                        #check that the datasets are compatible
all(names(x.q)%in%env.tid) 
                                        #match observations
all(env.tid[match(names(x.q),env.tid)] == names(x.q))
                                        #delimit co-occurrence and match
env <- env[match(names(x.q),env.tid),]
x.split <- paste(x$tree,x$quadrat,sep='_')
env.split <- paste(env$Tree.ID,env$Quad.Loc)
x.split <- as.character(x$tree)
env.split <- as.character(env$Tree.ID)
prb.wild <- tapply(env$Pct.Roughness,env.split,mean) #percent rough bark
                                        #age
age <- read.csv("../data/lcn/UintaMaster_LichenHeritNL_FallSpring_2012_ForLau.csv")
dbh <- age$DBH.cm_01
age.final <- age$AgeFinal.U
age <- data.frame(tree.id = age[,1], age.final = age$AgeFinal.U)
age[,1] <- tolower(age[,1])
age[,1] <- sub('_','\\.',age[,1])
age[,1] <- sub('-','\\.',age[,1])
age[,1] <- sub('\\?','',age[,1])
age[,1] <- sub('\\.0','\\.',age[,1])
age[age[,1] == 'gnu.85.1ftaway',1] <- 'gnu.85'
                                        #predict age
gnu19.dbh <- dbh[age$tree.id == 'gnu.19']
new <- data.frame(dbh=seq(min(dbh),max(dbh),by=0.1))
age.final <- na.omit(age.final)
pred.age <- predict(lm(age.final~dbh,data=age),new)
gnu19.age <- as.numeric(pred.age[new[,1] == gnu19.dbh])
                                        #
tree.age <- age[match(names(prb.wild), age[,1]),2]
tree.age[is.na(tree.age)] <- gnu19.age
names(tree.age) <- age[match(names(prb.wild),age[,1]),1]
age <- tree.age
                                        # percent cover
pc.wild <- unlist(lapply(wild.q, 
                         function(x) sum(apply(x, 1, 
                                               function(x) sign(sum(x))))))
                                        # richness
sr.wild <- unlist(lapply(wild.q, function(x) sum(sign(apply(x, 2, sum)))))
                                        # networks
cn.wild <- lapply(wild.q, coNet)
cn.mu.wild <- meanNet(cn.wild)
cn.d.wild <- distNet(cn.wild, method = 'bc')
                                        # network stats
ns.wild <- do.call(rbind, lapply(lapply(cn.wild, function(x) 
    abs(sign(x))), enaR:::structure.statistics))
                                        # centralization
dcen.wild <- unlist(lapply(cn.wild, function(x) 
    sna::centralization(x, FUN = sna::degree, normalize = FALSE)))
                                        # wild data frame
wild.dat <- data.frame(tree = names(tree.age), 
                       age = tree.age, BR = prb.wild, 
                       PC = pc.wild, SR = sr.wild,
                       L = ns.wild[, "L"], Cen = dcen.wild)

```


# Results 

```{r results, cache = TRUE}


### REML

### We know from Lamit's dissertation work that lichen communities are
### heritable, largely driven by bark roughness
### Do we find similar patterns?

## Create a list to generate a results table
h2.tab <- matrix("", 10, 4)
colnames(h2.tab) <- c("Response",  "H2", "R2", "p-value")

## Total cover ~ genotype
ptc.reml <- lme4::lmer(I(PC^(1/2)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
ptc.reml.pval <- RLRsim::exactRLRT(ptc.reml)
ptc.reml.pval
fligner.test(onc.dat$PC^(1/2), onc.dat$geno)
shapiro.test(residuals(ptc.reml))
h2.tab[1, "p-value"] <- ptc.reml.pval$"p.value"
h2.tab[1, "H2"] <- H2(ptc.reml, g = onc.dat$geno)
h2.tab[1, "R2"] <- R2(ptc.reml)
R2(ptc.reml)
h2.tab[1, "Response"] <- "Percent Lichen Cover"

## Species richness ~ genotype
spr.reml <- lme4::lmer(I(SR^(1/2)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
spr.reml.pval <- RLRsim::exactRLRT(spr.reml)
spr.reml.pval
shapiro.test(residuals(spr.reml))
fligner.test(onc.dat$SR^(1/2), onc.dat$geno)
h2.tab[2, "p-value"] <- spr.reml.pval$"p.value"
h2.tab[2, "H2"] <- H2(spr.reml, g = onc.dat$geno)
h2.tab[2, "R2"] <- R2(spr.reml)
R2(spr.reml)
h2.tab[2, "Response"] <- "Lichen Species Richness"


## Bark roughness REML
prb.reml <- lme4::lmer(I(BR^(1/2)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
prb.reml.pval <- RLRsim::exactRLRT(prb.reml)
prb.reml.pval
fligner.test(onc.dat$BR^(1/2), onc.dat$geno)
shapiro.test(residuals(prb.reml))
h2.tab[3, "p-value"] <- prb.reml.pval$"p.value"
h2.tab[3, "H2"] <- H2(prb.reml, g = onc.dat$geno)
h2.tab[3, "R2"] <- R2(prb.reml)
R2(prb.reml)
h2.tab[3, "Response"] <- "Percent Rough Bark"

## pH ~ genotype
ph.reml <- lme4::lmer(I(pH^(1/2)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
ph.reml.pval <- RLRsim::exactRLRT(ph.reml)
ph.reml.pval
fligner.test(log(onc.dat$pH), onc.dat$geno)
shapiro.test(residuals(ph.reml))
# h2.tab[1, "p-value"] <- ph.reml.pval$"p.value"
# h2.tab[1, "H2"] <- H2(ph.reml, g = onc.dat$geno)
# h2.tab[1, "R2"] <- R2(ph.reml)
R2(ph.reml)
# h2.tab[1, "Response"] <- "Percent Lichen Cover"

## condensed tannins  REML
ct.reml <- lme4::lmer(I(CT^(1/4)) ~ (1 | geno), 
                      data = na.omit(onc.dat), REML = TRUE)
ct.reml.pval <- RLRsim::exactRLRT(ct.reml)
ct.reml.pval
fligner.test(onc.dat$CT^(1/4), onc.dat$geno)
shapiro.test(residuals(ct.reml))


## CN ratio REML
cnr.reml <- lme4::lmer(I(CN^(1)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
cnr.reml.pval <- RLRsim::exactRLRT(cnr.reml)
cnr.reml.pval
fligner.test(onc.dat$CN^(1/1), onc.dat$geno)
shapiro.test(residuals(cnr.reml))


## Bark roughness PCA

####### This is a rough draft of chem data analysis with new pH #######
pca.onc <- princomp(na.omit(onc.dat[, c("pH", "CT", "CN")]))
cumsum(pca.onc[["sdev"]] / sum(pca.onc[["sdev"]]))
tpc.onc <- pca.onc[["scores"]][, 1:2]
onc.dat.test <- cbind(onc.dat, 
                      tpc.onc[match(rownames(onc.dat), rownames(tpc.onc)), ])

pc1.reml <- lme4::lmer(I(Comp.1^(1/1)) ~ (1 | geno), 
                       data = onc.dat.test, REML = TRUE)
RLRsim::exactRLRT(pc1.reml)
pc2.reml <- lme4::lmer(I(Comp.2^(1/1)) ~ (1 | geno), 
                       data = onc.dat.test, REML = TRUE)
RLRsim::exactRLRT(pc2.reml)
cn.d.onc.test <- distNet(cn.onc[as.character(onc.dat.test[!is.na(onc.dat.test[, "Comp.1"]), "tree.id"])])
adonis2(cn.d.onc.test ~ Comp.1 * Comp.2, data = onc.dat.test)
mantel(cn.d.onc.test ~ dist(na.omit(onc.dat[, c("pH", "CN", "CT")])))


## Is species richness correlated with percent cover?
cor.test(onc.dat[, "SR"], onc.dat[, "PC"], data = onc.dat)

## Were these correlated with bark roughness?
ptc.prb.lm <- lm(I(PC^(1/2)) ~ I(BR^(1/2)), data = onc.dat)
summary(ptc.prb.lm)
fligner.test(onc.dat$PC, onc.dat$BR)
shapiro.test(residuals(ptc.prb.lm))

spr.prb.lm <- lm(I(SR^(1)) ~ I(BR^(1/2)), data = onc.dat)
summary(spr.prb.lm)
fligner.test(onc.dat$SR^(1), onc.dat$BR)
shapiro.test(residuals(spr.prb.lm))

## COM ~ genotype + Bark roughness + PTC + SPR
set.seed(2)
rcom.ng.perm <- vegan::adonis2(onc.com.rel^(1/1) ~ BR + PC + SR, 
                               data = onc.dat, perm = 10000, mrank = TRUE)
set.seed(2)
rcom.perm <- vegan::adonis2(onc.com.rel^(1/1) ~ geno + BR + PC + SR, 
                            data = onc.dat, perm = 10000, mrank = TRUE)
set.seed(2)
com.ng.perm <- vegan::adonis2(onc.com^(1/1) ~ BR + PC + SR, 
                              data = onc.dat, perm = 10000, mrank = TRUE)
set.seed(2)
com.perm <- vegan::adonis2(onc.com^(1/1) ~ geno + BR + PC + SR, 
                           data = onc.dat, perm = 10000, mrank = TRUE)
rcom.ng.perm
rcom.perm

h2.tab[4, "p-value"] <- unlist(rcom.perm)["Pr(>F)1"]
h2.tab[4, "H2"] <- H2(rcom.perm, g = onc.dat$geno)
h2.tab[4, "R2"] <- R2(rcom.perm)
h2.tab[4, "Response"] <- "Lichen Community Composition"

## Is network similarity correlated with community composition?
ecodist::mantel(cn.d.onc ~ vegdist(onc.com.rel), mrank = TRUE)
spr.d <- dist(onc.dat$SR)
ptc.d <- dist(onc.dat$PC)
prb.d <- dist(onc.dat$BR)
### rough -> cover -> rich -> net
ecodist::mantel(cn.d.onc ~ vegdist(onc.com.rel) + spr.d + ptc.d + prb.d, mrank = TRUE)

## Partial Mantels using RFLP distance
ecodist::mantel(cn.mu.d.onc ~ rflp.d)
ecodist::mantel(onc.com.mu.d ~ rflp.d)
ecodist::mantel(cn.mu.d.onc ~ onc.com.mu.d)

## Was lichen network similarity determined by genotype?
set.seed(1234)
cn.perm <- vegan::adonis2(cn.d.onc.na ~ geno + 
                            BR + pH + CN + CT + 
                            PC + SR + SE, 
                          by = "term",
                          data = na.omit(onc.dat), 
                          permutations = 10000, mrank = FALSE)

cn.perm.ng <- vegan::adonis2(cn.d.onc ~ BR + PC  + SR, 
               data = onc.dat, permutations = 10000, mrank = TRUE)
cn.perm.ng
cn.perm
h2.tab[5, "p-value"] <- as.matrix(cn.perm)[1, "Pr(>F)"]
h2.tab[5, "H2"] <- H2(cn.perm, g = onc.dat[, "geno"], perm =10000)
h2.tab[5, "R2"] <- R2(cn.perm)
h2.tab[5, "Response"] <- "Lichen Network"
                                        # db rda for network similarity
dbr.cn.geno <- vegan::dbrda(cn.d.onc ~ geno, data = onc.dat, distance = "bray")
anova(dbr.cn.geno, permutations = 5000)
H2(dbr.cn.geno)

## What aspects of networks explained the similiarity?
## L = number of edges, LD = link density, C = connectivity,
## dcen = degree centrality
link.reml <- lme4::lmer(I(log(L + 0.00000001) ) ~ (1 | geno), 
                          data = onc.dat, REML = TRUE)
link.reml.pval <- RLRsim::exactRLRT(link.reml, nsim = 50000)
link.reml.pval
fligner.test(log(onc.dat$L + 0.0000001), onc.dat$geno)
shapiro.test(residuals(link.reml))
h2.tab[6, "p-value"] <- link.reml.pval$"p.value"
h2.tab[6, "H2"] <- H2(link.reml, g = onc.dat$geno)
h2.tab[6, "R2"] <- R2(link.reml)
R2(link.reml)
h2.tab[6, "Response"] <- "Number of Network Links"

                                        # network centrality
cen.reml <- lme4::lmer(I(Cen^(1/2))  ~ (1 | geno), 
                       data = onc.dat, REML = TRUE)
cen.reml.pval <- RLRsim::exactRLRT(cen.reml, nsim = 50000)
cen.reml.pval
fligner.test(onc.dat$L^(1/1), onc.dat$geno)
shapiro.test(residuals(cen.reml))
h2.tab[7, "p-value"] <- cen.reml.pval$"p.value"
h2.tab[7, "H2"] <- H2(cen.reml, g = onc.dat$geno)
h2.tab[7, "R2"] <- R2(cen.reml)
R2(cen.reml)
h2.tab[7, "Response"] <- "Network Centrality"

                                        # network modularity
mod.reml <- lme4::lmer(I(onc.ns[, "mod.lik"]^(1/4)) ~ (1 | geno), 
                       data = onc.dat, REML = TRUE)
mod.reml.pval <- RLRsim::exactRLRT(mod.reml)
mod.reml.pval
fligner.test(onc.ns[, "mod.lik"]^(1/4), onc.dat$geno)
shapiro.test(residuals(mod.reml))
h2.tab[8, "p-value"] <- mod.reml.pval$"p.value"
h2.tab[8, "H2"] <- H2(mod.reml, g = onc.dat$geno)
h2.tab[8, "R2"] <- R2(mod.reml)
h2.tab[8, "Response"] <- "Network Modularity"

## Added diversity and evenness

## Species diversity ~ genotype
spd.reml <- lme4::lmer(I(SD^(1/2)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
spd.reml.pval <- RLRsim::exactRLRT(spd.reml)
spd.reml.pval
shapiro.test(residuals(spd.reml))
fligner.test(onc.dat$SD^(1/2), onc.dat$geno)
h2.tab[9, "p-value"] <- spd.reml.pval$"p.value"
h2.tab[9, "H2"] <- H2(spd.reml, g = onc.dat$geno)
h2.tab[9, "R2"] <- R2(spd.reml)
R2(spd.reml)
h2.tab[9, "Response"] <- "Lichen Species Diversity"

## Species diversity ~ genotype
spe.reml <- lme4::lmer(I(SE^(1/4)) ~ (1 | geno), 
                       data = na.omit(onc.dat), REML = TRUE)
spe.reml.pval <- RLRsim::exactRLRT(spe.reml)
spe.reml.pval
shapiro.test(residuals(spe.reml))
fligner.test(onc.dat$SD^(1/2), onc.dat$geno)
h2.tab[10, "p-value"] <- spe.reml.pval$"p.value"
h2.tab[10, "H2"] <- H2(spe.reml, g = onc.dat$geno)
h2.tab[10, "R2"] <- R2(spe.reml)
R2(spe.reml)
h2.tab[10, "Response"] <- "Lichen Species Evenness"

                                        # network stats in relation to other variables
L.aov <- aov(I(log(L + 0.000001)) ~ BR + PC + SR, data = onc.dat)
summary(L.aov)
shapiro.test(residuals(L.aov))
cen.aov <- aov(I(Cen^(1/2)) ~ BR + PC + SR, data = onc.dat)
summary(cen.aov)
shapiro.test(residuals(cen.aov))
mod.aov <- aov(I(onc.ns[, "mod.lik"]^(1/4)) ~ BR + PC + SR, data = onc.dat)
summary(mod.aov)
shapiro.test(residuals((mod.aov)))

## 
cor.test(onc.ns[, "L"], onc.ns[, "Cen"])

                                        # are these metrics correlated with network similarity
L.d <- dist(onc.dat$L)
cen.d <- dist(onc.dat$Cen)
mod.d <- dist(cn.mod.onc)
cn.L.cen.perm <- adonis2(cn.d.onc ~ L + Cen, data = onc.dat, mrank = TRUE)

## So, are there patterns in the centrality of individual lichen species?
sppcen.test <- apply(cen.spp[, apply(cen.spp, 2, sum) >= 2], 2, function(x)
    lme4::lmer(I(x^(1/2)) ~ (1 | geno), data = onc.dat, REML = TRUE))
sppcen.pval <- lapply(sppcen.test, RLRsim::exactRLRT)
sppcen.tab <- do.call(rbind, lapply(sppcen.pval, function(x)
    c(x[["statistic"]], x[["p.value"]])))
sppcen.h2 <- round(unlist(lapply(sppcen.test, H2)), 3)
sppcen.h2

## Mean centrality of species
sort(apply(cen.spp, 2, mean), decreasing = TRUE)

## Ordinations
### nits = 10, 
### iconf = random
### epsilon = 1e-12 = acceptable change in stress
### maxit = 500 = maximum number of iterations
ord.com <- nmds.min(nms.com, 3)
## Minimum stress for given dimensionality:  0.1008923 
## r^2 for minimum stress configuration:  0.9357192 
ord.cn <- nmds.min(nms.cn, 2)
## Minimum stress for given dimensionality:  0.01065177 
## r^2 for minimum stress configuration:  0.9993026 
## checking variance explained by ordinations
ord1.cn.reml <- lme4::lmer(I(ord.cn[, 1]^(1/1)) ~ (1 | geno), 
                       data = onc.dat, REML = TRUE)
ord2.cn.reml <- lme4::lmer(I(ord.cn[, 2]^(1/1)) ~ (1 | geno), 
                       data = onc.dat, REML = TRUE)
ord1.cn.reml.pval <- RLRsim::exactRLRT(ord1.cn.reml)
ord2.cn.reml.pval <- RLRsim::exactRLRT(ord2.cn.reml)
ord1.cn.reml.pval
ord2.cn.reml.pval
fligner.test(ord.cn[, 1]^(1/1), onc.dat$geno)
fligner.test(ord.cn[, 2]^(1/1), onc.dat$geno)

ord1.com.reml <- lme4::lmer(I(ord.com[, 1]^(1/1)) ~ (1 | geno), 
                       data = onc.dat, REML = TRUE)
ord2.com.reml <- lme4::lmer(I(ord.com[, 2]^(1/1)) ~ (1 | geno), 
                       data = onc.dat, REML = TRUE)
ord1.com.reml.pval <- RLRsim::exactRLRT(ord1.com.reml)
ord2.com.reml.pval <- RLRsim::exactRLRT(ord2.com.reml)
ord1.com.reml.pval
ord2.com.reml.pval
fligner.test(ord.com[, 1]^(1/1), onc.dat$geno)
fligner.test(ord.com[, 2]^(1/1), onc.dat$geno)
fligner.test(ord.com[, 3]^(1/1), onc.dat$geno)
summary(lm(ord.cn[, 1] ~ SR + PC, data = onc.dat))
summary(lm(ord.cn[, 2] ~ SR + PC, data = onc.dat))
summary(lm(ord.com[, 1] ~ SR + PC, data = onc.dat))
summary(lm(ord.com[, 2] ~ SR + PC, data = onc.dat))


## Lichen size distribution
## X. gallericulata thalli are about 0.22 +/- 0.003 cm^2 on average
## with an average median size of 0.12 +/- 0.001 cm^2
## and, size does not vary significantly with genotype.
xgs.reml <- lme4::lmer(I(mean.thallus) ~ (1 | geno), 
                       data = xgs.data[xgs.data$geno %in% names(which(table(xgs.data$geno) > 2)), ],
                       REML = TRUE)
xgs.median.reml <- lme4::lmer(median.thallus ~ (1 | geno), 
                       data = xgs.data[xgs.data$geno %in% names(which(table(xgs.data$geno) > 2)), ],
                       REML = TRUE)
RLRsim::exactRLRT(xgs.reml)
RLRsim::exactRLRT(xgs.median.reml)
fligner.test(xgs.data$mean.thallus, xgs.data$geno)
fligner.test(xgs.data$median.thallus, xgs.data$geno)
mean(xgs.data$mean.thallus)
sd(xgs.data$mean.thallus) / (length(xgs.data$mean.thallus) - 1)
mean(xgs.data$median.thallus)
sd(xgs.data$median.thallus) / (length(xgs.data$median.thallus) - 1)
                                        # ONC and Wild Stand (Uintah)
all.dat <- rbind(wild.dat[, c("BR", "PC", "SR", "L", "Cen")], 
                 onc.dat[, c("BR", "PC", "SR", "L", "Cen")])
                                        # Network distances
cn.all <- cn.wild
for (i in 1:length(cn.wild)){
    cn.all[[i]] <- cn.wild[[i]][match(rownames(cn.onc[[1]]), rownames(cn.wild[[i]])), 
                                match(colnames(cn.onc[[1]]), colnames(cn.wild[[i]]))]
}
cn.all <- append(cn.all, cn.onc)
cn.d.all <- distNet(cn.all, method = "bc")
cn.nms.geno <- c(rep("wild", length(cn.wild)), onc.geno)
if (!exists("cn.nms.all")){
    set.seed(12345)
    cn.nms.all <- nmds.min(nmds(cn.d.all, 2, 2))
    vec.all <- envfit(cn.nms.all, all.dat)
                                        # jitter identical points
    cn.nms.all[cn.nms.geno == "H10", ] <- cn.nms.all[cn.nms.geno == "H10", ] - 0.2
}

```

```{r bp_mod, eval = FALSE, echo = FALSE}

### What is the structure of the bipartite networks?
                                        # test for modularity 
                                        # modularity p-values
p.mod <- c(wild = length(mods.wild.sweb[mods.wild.sweb <= mod.wild]) / length(mods.wild.sweb),
           onc = length(mods.onc.sweb[mods.onc.sweb <= mod.onc]) / length(mods.onc.sweb), 
           pit = length(mods.pit.sweb[mods.pit.sweb <= mod.pit]) / length(mods.pit.sweb))
                                        # ses modularity
ses.mod <- c(wild = (mod.wild - mean(mods.wild.sweb)) / sd(mods.wild.sweb),
             onc = (mod.onc - mean(mods.onc.sweb)) / sd(mods.onc.sweb),
             pit = (mod.pit - mean(mods.pit.sweb)) / sd(mods.pit.sweb))
# nest.pit <- bipartite::nestedness(pit.com.gm.rel)
sna::gplot(sp.up, gmode = "graph", displaylabels = TRUE, lwd = sp.up)

```

# Tables

```{r h2_table, results = "asis"}

h2.tab[, "H2"] <- round(as.numeric(h2.tab[, "H2"]), digits = 5)
h2.tab[, "R2"] <- round(as.numeric(h2.tab[, "R2"]), digits = 5)
h2.tab[, "p-value"] <- round(as.numeric(h2.tab[, "p-value"]), digits = 5)
h2.tab <- h2.tab[order(h2.tab[, "H2"], decreasing = TRUE), ]
h2.xtab <- xtable::xtable(h2.tab, caption = 
    "Genotypic effects of cottonwood trees on the associated lichen community.", 
                          label = "tab:h2_table")
print(h2.xtab,
      type = "latex",
      include.rownames = FALSE,
      include.colnames = TRUE
)

```

```{r write_h2_table, results = "hide", echo = FALSE}

print(h2.xtab,
      type = "latex",
      file = "../results/h2_table.tex",
      include.rownames = FALSE,
      include.colnames = TRUE
)

```


```{r com_ng_perm_table, results = "asis"}

                                        # community permanova
rcom.ng.perm.xtab <- xtable::xtable(rcom.ng.perm, caption = 
    "PerMANOVA Pseudo-F Table showing the predictors of community similarity.", 
                          label = "tab:com_ng_perm")
print(rcom.ng.perm.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_com_ng_perm_table, results = "hide", echo = FALSE}

print(rcom.ng.perm.xtab,
      type = "latex",
      file = "../results/com_ng_perm_table.tex",
   include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r rcom_perm, results = "asis"}

rcom.perm.xtab <- xtable::xtable(rcom.perm, caption = 
    "PerMANOVA Pseudo-F Table showing the predictors of community similarity.", 
                          label = "tab:rcom_perm")
print(rcom.perm.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_rcom_perm, results = "hide", echo = FALSE}

print(rcom.perm.xtab,
      type = "latex",
      file = "../results/rcom_perm.tex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r cn_perm_ng, results = "asis"}

                                        # network permanova
cn.perm.ng.xtab <- xtable::xtable(cn.perm.ng, caption = 
    "PerMANOVA Pseudo-F Table showing the predictors of network similarity.", 
                          label = "tab:cn_perm_ng")
print(cn.perm.ng.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_cn_perm_ng, results = "hide", echo = FALSE}

print(cn.perm.ng.xtab,
      type = "latex",
      file = "../results/cn_perm_ng.tex",
   include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r cn_perm, results = "asis"}

cn.perm.xtab <- xtable::xtable(cn.perm, caption = 
    "PerMANOVA Pseudo-F Table showing the predictors of network similarity.", 
                          label = "tab:cn_perm")
print(cn.perm.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_cn_perm, results = "hide", echo = FALSE}

print(cn.perm.xtab,
      type = "latex",
      file = "../results/cn_perm.tex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r L_aov, results = "asis"}

                                        # network metrics anova
L.aov.xtab <- xtable::xtable(L.aov, caption = 
    "ANOVA F Table showing the predictors of the number of network links.", 
                          label = "tab:L_aov")
print(L.aov.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_L_aov, results = "hide", echo = FALSE}

print(L.aov.xtab,
      type = "latex",
      file = "../results/L_aov.tex",
   include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r cen_aov, results = "asis"}

cen.aov.xtab <- xtable::xtable(cen.aov, caption = 
    "ANOVA F Table showing the predictors of network centralization.", 
                          label = "tab:cen_aov")
print(cen.aov.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_cen_aov, results = "hide", echo = FALSE}

print(cen.aov.xtab,
      type = "latex",
      file = "../results/cen_aov.tex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r cn_L_cen_perm, results = "asis"}

                                        # networks and network metrics
                                        # permanova
cn.L.cen.perm.xtab <- xtable::xtable(cn.L.cen.perm, caption = 
    "PerMANOVA Pseudo-F Table showing the predictors of network similarity.", 
                          label = "tab:cn_L_cen_perm")
print(cn.L.cen.perm.xtab,
      type = "latex",
      include.rownames = TRUE,
      include.colnames = TRUE
)

```

```{r write_cn_L_cen_perm, results = "hide", echo = FALSE}

print(cn.L.cen.perm.xtab,
      type = "latex",
      file = "../results/cn_L_cen_perm.tex",
   include.rownames = TRUE,
      include.colnames = TRUE
)

```

# Plots

## Figure: Genotype barplots Community composition NMDS with vectors 
```{r com_chplot_onc, height = 5, width = 5}

par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1) / 1)
chp.coord <- ch.plot(ord.com[, 1:2], onc.geno, 
                     cex = 2, mu.pch = 19, 
                     pt.col = "white", 
                     bar.col = "darkgrey")
text(chp.coord, labels = rownames(chp.coord))
plot(vec.com, col = "black", lwd = 7)

```

## Figure: Lichen networks
```{r cn_onc, height = 8, width = 8}

par(mfrow = c(2, 2), mar = c(0, 0.1, 1.0, 0.1))
set.seed(123)
net.col <- sign(meanNet(cn.mu.onc))
net.col[net.col == -1] <- 2
net.col[net.col == 1] <- 1
net.elwd <- (abs(meanNet(cn.mu.onc)) * 10)^2
coord <- gplot(abs(meanNet(cn.mu.onc)), gmode = "digraph", 
      displaylabels = TRUE, 
      edge.lwd = net.elwd, 
      edge.col = net.col,
      vertex.col = "black", 
      vertex.cex = 0.5,
      arrowhead.cex = 0.5, 
      label.cex = 1, 
      main = "All Genotypes")
cn.mu.plot <- cn.mu.onc[names(cn.mu.onc) %in% 
                        c("996", "WC5", "1008")]
cn.mu.plot <- cn.mu.plot[
  order(unlist(lapply(cn.mu.plot, 
                      function(x) sum(abs(sign(x))))))]
for (i in 1:length(cn.mu.plot)){
        net.col <- sign(cn.mu.plot[[i]])
        net.col[net.col == -1] <- 2
        net.col[net.col == 1] <- 1
        net.elwd <- (abs(cn.mu.plot[[i]]) * 10)^2
        set.seed(123)
        gplot(abs(cn.mu.plot[[i]]), gmode = "digraph", 
              displaylabels = TRUE, 
              coord = coord,
              edge.lwd = net.elwd, 
              edge.col = net.col,
              vertex.col = "black", 
              vertex.cex = 0.5,
              arrowhead.cex = 0.5, 
              label.cex = 1, 
              main = names(cn.mu.plot)[i])
}

```

## Figure: Genotype network similarity by genotype
```{r cn_chplot, height = 8, width = 8}

par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1))
chp.coord <- ch.plot(cn.nms.onc, onc.geno, 
                     cex = 3, lwd = 2.5, mu.pch = 19, 
                     pt.col = "white", 
                     bar.col = "darkgrey")
text(chp.coord, labels = rownames(chp.coord), cex = 0.65)
plot(vec.cn, col = "black")

```

## Figure: A) Lichen networks

## Figure: (A) Linkage and centrality by genotype and (B) Total
##   cover and species richness predict L and Cen
```{r cn_metrics, height = 8, width = 9}

mdc.plot(onc.dat[, "geno"], onc.dat[, "L"], ylim = c(-1, 1.75), 
         xlab = "Tree Genotype", ylab = "Standardized Metric",
         ord = order(tapply(onc.dat[, "L"], onc.dat[, "geno"], mean), decreasing = TRUE))
mdc.plot(onc.dat[, "geno"], onc.dat[, "Cen"], add = TRUE, pch = 1, 
         ord = order(tapply(onc.dat[, "L"], onc.dat[, "geno"], mean), decreasing = TRUE))
legend("topright", legend = c("Links", "Centralization"), pch = c(19, 1), bty = "none")

```


## Supplementary Figure: Lichen size distribution
```{r xg_size, height = 5, width = 5}

plot(density(xgs.data$median.thallus),
     xlab = "Median Lichen Thallus Area (cm^2)", 
     main = "")
abline(v = median(xgs.data$median.thallus, na.rm = TRUE), lty = 2)

```


### Figure 2
```{r cn_chplot_onc, height = 5, width = 12}

par(mfrow = c(1, 2), mar = c(5.1, 4.1, 4.1, 2.1) / 2)
gplot(meanNet(cn.mu.onc), gmode = "graph", 
      displaylabels = TRUE, 
      edge.lwd = meanNet(cn.mu.onc) * 20, 
      vertex.col = "darkgrey")
legend("topleft", legend = "A", bty = "n", cex = 1.5)
chp.coord <- ch.plot(cn.nms.onc, onc.geno, cex = 1.5)
plot(nv.onc, col = "darkgrey")
legend("topleft", legend = "B", bty = "n", cex = 1.5)

```

```{r bp_net_onc}

par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1))
bipartite::plotweb(pw.onc, method = "normal", 
                   text.rot = 45, 
                   col.low = col.pal[mods.onc$tree], 
                   col.high = col.pal[mods.onc$sp],
                   bor.col.low = col.pal[mods.onc$tree], 
                   bor.col.high = col.pal[mods.onc$sp],
                   col.interaction = "grey70",
                   bor.col.interaction = "grey70", 
                   labsize = 1.5)

```

```{r chp_com_onc}

ch.plot(nms.onc, onc.geno)
## plot(cv.onc, col = "grey30")
## legend("topleft", legend = "A")

```



```{r connect_geno, width = 12, height = 7}

g.order <- tapply(ns.onc[, "C"], onc.geno, mean)
g.order <- names(g.order)[order(g.order, decreasing = TRUE)]
onc.g <- factor(onc.geno, levels = g.order)
plot(ns.onc[, "C"] ~ onc.g, xlab = "Tree Genotype", ylab = "Lichen Network Connectance (C)")

```

## Which wild uintah trees are similar to garden trees?

```{r cn_chplot_all, width = 5, height = 7}

coords <- ch.plot(cn.nms.all, cn.nms.geno, mu.pch = "", cex = 2)
points(coords, pch = 19, col = "white", cex = 2)
text(coords[!grepl("wild", rownames(coords)), ],
     labels = rownames(coords)[!grepl("wild", rownames(coords))],
     col = "black")
text(coords[grep("wild", rownames(coords)), 1],
     coords[grep("wild", rownames(coords)), 2],
     labels = "Wild", col = "red")
plot(vec.all, col = "black", cex = 1.23)

```

# Send results to manuscript

```{r }

manuscript.dir <- "../../lcn_manuscript"
### Send tables and figures to manuscript directory
if (exists("manuscript.dir")){
    tabs.figs <- dir(manuscript.dir)
    tab.fig.update <- dir("../results/lcn_notebook_files/figure-latex/", 
                          full.names = TRUE)[
                              dir("../results/lcn_notebook_files/figure-latex/") %in% tabs.figs]
    tab.fig.update <- c(tab.fig.update, 
                        dir("../docs", full.names = TRUE)[dir("../docs") %in% tabs.figs])
    sapply(tab.fig.update, file.copy, to = manuscript.dir, overwrite = TRUE)
                                        # supplementary figures
    si.dir <- paste0(manuscript.dir, "/supplement")
    si <- dir(si.dir)
    si.update <- dir("../results/lcn_notebook_files/figure-latex/", 
                     full.names = TRUE)[
                         dir("../results/lcn_notebook_files/figure-latex/") %in% si]
    si.update <- c(si.update, dir("../docs", full.names = TRUE)[dir("../docs") %in% si])
    sapply(si.update, file.copy, to = si.dir, 
           overwrite = TRUE)
}

```


# Loading and pre-processing data

```{r load-data-echo, echo = TRUE, eval = FALSE}

## This is a place-holder for the echoing the data loading code. 

```

